// Code generated by "github.com/hedhyw/semerr"; DO NOT EDIT.

package httperr

import (
	"errors"
	"net/http"

	"github.com/hedhyw/semerr/internal/pkg/multierr"
	"github.com/hedhyw/semerr/pkg/v1/semerr"
)

// Code returns http status code for err. In case of joined errors
// it returns the first code found in the chain.
func Code(err error) int {
	code := codeRecursion(err)
	if code == 0 {
		return http.StatusInternalServerError
	}

	return code
}

func codeRecursion(err error) int {
	switch err.(type) {
	case nil:
		return http.StatusOK
	case semerr.StatusRequestTimeoutError:
		return 408
	case semerr.InternalServerError:
		return 500
	case semerr.BadRequestError:
		return 400
	case semerr.UnsupportedMediaTypeError:
		return 415
	case semerr.StatusGatewayTimeoutError:
		return 504
	case semerr.NotFoundError:
		return 404
	case semerr.ConflictError:
		return 409
	case semerr.ForbiddenError:
		return 403
	case semerr.TooManyRequestsError:
		return 429
	case semerr.RequestEntityTooLargeError:
		return 413
	case semerr.UnimplementedError:
		return 501
	case semerr.ServiceUnavailableError:
		return 503
	case semerr.UnauthorizedError:
		return 401
	}

	if err := errors.Unwrap(err); err != nil {
		return codeRecursion(err)
	}

	if multiErr, ok := err.(multierr.MultiError); ok && multiErr != nil {
		for _, err := range multiErr.Unwrap() {
			code := codeRecursion(err)

			if code != 0 {
				return code
			}
		}
	}

	return 0
}

// Wrap wraps the `err` with an error corresponding to the `code`.
// If there is no `err` for this code then the `err` will be returned
// without wrapping.
func Wrap(err error, code int) error {
	switch code {
	case 408:
		return semerr.NewStatusRequestTimeoutError(err)
	case 500:
		return semerr.NewInternalServerError(err)
	case 400:
		return semerr.NewBadRequestError(err)
	case 504:
		return semerr.NewStatusGatewayTimeoutError(err)
	case 404:
		return semerr.NewNotFoundError(err)
	case 409:
		return semerr.NewConflictError(err)
	case 403:
		return semerr.NewForbiddenError(err)
	case 429:
		return semerr.NewTooManyRequestsError(err)
	case 413:
		return semerr.NewRequestEntityTooLargeError(err)
	case 501:
		return semerr.NewUnimplementedError(err)
	case 503:
		return semerr.NewServiceUnavailableError(err)
	case 401:
		return semerr.NewUnauthorizedError(err)
	default:
		return err
	}
}
